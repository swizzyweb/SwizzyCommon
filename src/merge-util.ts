// Generated by chatgpt

export function deepClone<T>(obj: T): T {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }

  if (obj instanceof Date) {
    return new Date(obj.getTime()) as any;
  }

  if (Array.isArray(obj)) {
    return obj.map((item) => deepClone(item)) as any;
  }

  if (obj instanceof Map) {
    const clonedMap = new Map();
    for (const [key, value] of obj.entries()) {
      clonedMap.set(key, deepClone(value));
    }
    return clonedMap as any;
  }

  if (obj instanceof Set) {
    const clonedSet = new Set();
    for (const value of obj.values()) {
      clonedSet.add(deepClone(value));
    }
    return clonedSet as any;
  }

  const clonedObj: any = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      clonedObj[key] = deepClone((obj as any)[key]);
    }
  }
  return clonedObj;
}

export function deepMerge<T extends object, U extends object>(
  target: T,
  source: U,
): T & U {
  if (typeof target !== "object" || target === null)
    return deepClone(source) as T & U;
  if (typeof source !== "object" || source === null)
    return deepClone(target) as T & U;

  if (source instanceof Date) {
    return deepClone(source) as any;
  }

  if (source instanceof Map) {
    const mergedMap = new Map();
    const targetMap = target instanceof Map ? target : new Map();
    for (const [key, value] of (targetMap as any).entries()) {
      mergedMap.set(key, deepClone(value));
    }
    for (const [key, value] of (source as any).entries()) {
      mergedMap.set(key, deepClone(value));
    }
    return mergedMap as any;
  }

  if (source instanceof Set) {
    const mergedSet = new Set();
    const targetSet = target instanceof Set ? target : new Set();
    for (const value of (targetSet as any).values()) {
      mergedSet.add(deepClone(value));
    }
    for (const value of (source as any).values()) {
      mergedSet.add(deepClone(value));
    }
    return mergedSet as any;
  }

  let output: any = Array.isArray(target) ? [...target] : { ...target };

  if (Array.isArray(target) && Array.isArray(source)) {
    for (const item of source) {
      if (
        !output.some(
          (existing: any) => JSON.stringify(existing) === JSON.stringify(item),
        )
      ) {
        output.push(deepClone(item));
      }
    }
    return output;
  }

  for (const key of Object.keys(source)) {
    const sourceValue = (source as any)[key];
    const targetValue = (target as any)[key];

    if (Array.isArray(sourceValue) && Array.isArray(targetValue)) {
      output[key] = deepMerge(targetValue, sourceValue);
    } else if (typeof sourceValue === "object" && sourceValue !== null) {
      output[key] = deepMerge(targetValue || {}, sourceValue);
    } else {
      output[key] = deepClone(sourceValue);
    }
  }

  return output;
}
